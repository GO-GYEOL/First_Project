atom에서 사용할 수 있도록 memo 데이터 구조 만들다보니 여느 api에서 보이는 json 구조를 띄게 되었음.  순서가 필요할 땐 객체를 사용할 수 없다는걸 알았다. dnd같은 경우 드래그를 통해 순서를 바꿔줘야하므로 배열형태로 만드는 것이 맞는 것 같다.
이전에 ellie 가 알려준 방법은 순서를 바꿔야 하는 경우에 사용할 수 없음. 



지금 안되는거 너비때문인가? 너비 고정시켜줘야되나?



onDragEnd에서
// 배열 내부 객체의 속성명이 특정값과 매칭되는 객체 선택하는 방법....
const board = memoCopy.filter((x) => Object.keys(x).toString() == source.droppableId)[0];

board끼리 이동
key에 index를 넣어주었다가 계속 문제 발생했음. 그래서 board끼리 두번 이상으로 움직이면 오류났었음. 로직 문제인 줄 알고 3일은 헤맸음.


같은 board 내 card 이동
map하려면 const 해서 변수명 지정해줘야되네. ref 자체 안건드림. 그냥 하나의 변수를 깊은복사 해버리는 것임. 그리고 return을 통해 그 깊은복사된 변수를 조작하는 것이고. 그래서 const 해서 변수명 지정해줘야 쓸 수 있다. 


// 아 이전에 footer에서 했던 방식대로 하면 안되는 이유! 전개연산자 사용해서 참조형 데이터 복사하는건 깊은 복사이지만 반쪽짜리 깊은 복사이다. 첫번째 층만 깊은 복사를 하고 그 다음층은 얕은복사를 한다. 그래서 footer에서는 첫번째 층만 건드리니 상관 없었으나, 여기선 card 즉 두번째 층까지 건드리니 전개연산자를 한번 더 써줘야한다.